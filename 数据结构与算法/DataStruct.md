# 第一章 绪论
---

## 数据结构

数据结构由一个四元组来表示：  
```  
  Data_Structure = (D,L,S,O)  
```  
即：数据元素、数据元素之间的逻辑关系、逻辑关系在计算机中的存储表示、以及所规定的操作这三个部分。

## 逻辑结构

逻辑结构可以归结为以下四类：  
1. 线性结构  
2. 树形结构：非线性结构  
3. 图形结构  非线性结构  
4. 集合结构  

## 存储结构(物理结构)

1. 顺序存储：把逻辑上相邻的元素存储在物理位置相邻的存储单元中。  
2. 链式存储：把数据元素中添加一些地址域或辅助结构，用于存放数据元素之间的关系。  

## 数据结构的操作(Operation)

数据元素的查找、插入、删除、遍历和排序  

## 数据类型

数据类型：是程序设计语言中用来刻画操作对象的特征的一个值的集合和定义在此集合上的一组操作的总称。  

## 算法

1. 用途：设计并实现一种用计算机来解决问题的方法。  
2. 是满足下述性质的指令序列：
	* 输入： 有零个或多个外部量作为算法的输入。  
	* 输出： 算法产生至少一个量作为输出。  
	* 确定性： 组成算法的每条指令清晰、无歧义。  
	* 有限性： 算法中每条指令的执行次数有限，执行每条指令的时间也有限。  
3. 计算机问题求解五步骤：  
	1. 问题的理解：清楚问题的输入、要求和输出。  
	2. 数据结构设计：一方面要选择或设计能有效表示和存储应用问题中所设计的数据对象的数据结构，同时还要选择或设计能支持算法策略实现的数据结构。  
	3. 算法设计：包括选择算法策略、用适当的方式描述和逐步细化算法步骤。  
	4. 算法分析：发现有改进完善之处，返回第二步，重新选择或设计数据结构、重新设计算法。  
	5. 程序实现：用某种计算机程序设计语言，定义数据结构、编写实现算法的代码，在计算机上调试和运行程序。  
4. 好的算法应该具备以下特征：  
	* 正确性：正确性是对算法能否正确求解问题的评价，是首要和最基本的特征。  
	* 可读性：可读性是对算法描述的思路、层次的评价。好的算法应该是思路清晰、层次分明、阅读和修改容易。  
	* 健壮性：健壮性是对算法在异常情况下处理能力的评价。好的算法在出现异常或非法数据时，在操作不当时，算法都能作适当处理。  
	* 高效性：算法的效率是对求解同样问题的不同算法所占用的时间或空间的评价。好的算法应该是高效的，即求解问题所占用存储空间少，执行时间短。  
5. 算法复杂性分析  
	* 算法复杂性是算法运行所需要的计算机资源的量，需要时间资源的量称为**时间复杂性**，需要的空间资源的量为**空间复杂性**。这个量应该只依赖于算法要解问题的**规模**、算法的**输入**和**算法本身**。如果分别用N、I和A表示要解问题的规模、算法的输入和算法本身，而且用C表示复杂性，那么，应该有C=F(N,I,A)。一般把时间复杂性和空间复杂性分开，并分别用T和S来表示，则有：T=T(N,I)和S=S(N,I)。  
	* 一个算法用程序设计语言表示后，算法就是由一组语句构成，算法的执行效率就由个语句执行的次数所决定。  
	* 一个算法花费的时间与算法中语句的执行次数成正比例，那个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数(计算步)称为语句频度或时间频度。记为T(n)。  
	* 一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f(n)，因此，算法的时间复杂度记做：T(n)=O(f(n))。  
6. 最常用的关系式  
	* 多项式 a<sub>0</sub>+a<sub>1</sub>n+...+a<sub>d</sub>n<sup>d</sup>=Θ(n<sup>d</sup>)其中a<sub>d</sub>>0。  
	* 对数 O(log<sub>a</sub>n) = O(log<sub>b</sub>n),其中a，b > 0为常数.  
	* 对数 对任意x > 0,log n = O(n<sup>x</sup>).  
	* 指数 对任意r > 1 和 d > 0, n<sup>d</sup> = O(r<sup>n</sup>).  

# 第二章 线性表(Linear_List)
---

**线性表**是最基本和最常用的一类数据结构，它表示的是线性结构。在线性结构中，数据元素之间存在着一对一的关系，其特点是数据元素之间按某种规定存在一个**顺序关系**。  

主要内容：  
> 线性表基本概念  
> 线性表的两种存储结构：顺序和链式存储结构  
> 线性表的简单应用  
> 线性表的扩展  

## 线性表的定义
* 线性表：n个同类型数据元素的有限序列，记为：  
	L = (a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>i</sub>, ..., a<sub>n</sub>)  
	L为表名  
	i为数据元素a<sub>i</sub>在线性表中的位序  
	n为线性表的表长；n = 0时称为空表  
	数据元素之间的关系是：  
	a<sub>i-1</sub>领先于a<sub>i</sub>,a<sub>i</sub>领先于a<sub>i+1</sub>  
	称a<sub>i-1</sub>是a<sub>i</sub>的直接前驱，a<sub>i+1</sub>是a<sub>i</sub>的直接后继，  
	除第一元素a<sub>i</sub>外，均有唯一的前驱  
	除最后元素a<sub>n</sub>外，均有唯一的后继  

* 线性表的基本函数：  
	```C++
		//初始化
		Status Init();
		//销毁
		void Destory();
		//清除
		void Clear();
		//判断是否为空
		bool Empty();
		//数据数量
		int Size();
		//从pos的位置取出，放入到elem指定位置
		Status Retrival(int pos, ElemType* elem);
		//定位，查找
		Status Locate(ElemType elem, int* pos);
		//插入
		Status Insert(int pos, ElemType elem);
		//删除
		Status Delete(int pos);
		//直接前驱
		Status Prior(int pos, ElemType* elem);
		//直接后继
		Status Next(int pos, ElemType* elem);
	```  